# ID冲突问题 - 快速FAQ

## 版本：v3.6.2

---

## ❓ 核心问题

**Q: 合并多个数据库时，自增ID会冲突吗？**

**A: 不会！** 系统已经完全处理了这个问题。

---

## 🔍 一句话解释

**所有ID（patient_id, surgery_id等）在导入时都会被排除，由目标数据库重新自动生成，因此绝对不会冲突。**

---

## 📊 示例对比

### 源数据库A
```
Patient ID=1, hospital_id='H001'
  └─ Surgery ID=1
  └─ Surgery ID=2
```

### 源数据库B  
```
Patient ID=1, hospital_id='H002'  ← ID与A相同
  └─ Surgery ID=1  ← ID与A相同
```

### 目标数据库（已有100条患者记录）

**导入A后：**
```
Patient ID=101, hospital_id='H001'  ← 新ID
  └─ Surgery ID=201  ← 新ID
  └─ Surgery ID=202  ← 新ID
```

**再导入B后：**
```
Patient ID=102, hospital_id='H002'  ← 新ID
  └─ Surgery ID=203  ← 新ID
```

**结果：没有任何冲突！**

---

## 💻 技术保障

### 1. ID排除机制

```python
# 导入时自动排除所有ID
data = {k: v for k, v in row.items() 
        if k not in ("surgery_id", "patient_id")}

# 结果：源ID完全不会被复制
```

### 2. 自动生成新ID

```python
# SQLite AUTOINCREMENT 自动分配
new_id = db.insert_surgery(new_patient_id, data)

# 保证：
# - ID永不重复
# - ID永不回收  
# - ID单调递增
```

### 3. 外键自动映射

```python
# 建立源ID到目标ID的映射
id_map = {
    1: 101,  # 源Patient ID=1 → 目标ID=101
    2: 102   # 源Patient ID=2 → 目标ID=102
}

# 子记录自动使用新ID
for src_pid, dest_pid in id_map.items():
    db.insert_surgery(dest_pid, surgery_data)
```

---

## ✅ 验证方法

### 方法1：健康检查（推荐）

```
菜单 → 文件 → 数据库健康检查...
```

自动检查：
- ✅ 主键ID唯一性
- ✅ 外键关系完整性
- ✅ 孤立记录检测

### 方法2：SQL查询

```sql
-- 检查Surgery表ID是否有重复
SELECT surgery_id, COUNT(*) 
FROM Surgery 
GROUP BY surgery_id 
HAVING COUNT(*) > 1;

-- 返回空 = 没有重复 = 安全✓
```

### 方法3：查看日志

```
查看 importer.log
如果有ID冲突会报错：
  "UNIQUE constraint failed: Surgery.surgery_id"
  
没有此类错误 = 安全✓
```

---

## 🛡️ 为什么安全

| 机制 | 说明 | 保障 |
|-----|------|------|
| ID排除 | 导入时不复制源ID | 100% |
| AUTOINCREMENT | SQLite保证ID唯一 | 100% |
| 事务隔离 | 原子操作无竞态 | 100% |
| 外键约束 | 确保关系正确 | 100% |
| 健康检查 | 自动验证 | 100% |

---

## 🎯 应该担心什么？

### ❌ 不需要担心

- ❌ ID冲突
- ❌ 数据覆盖
- ❌ 关系混乱

### ✅ 应该注意

- ✅ 导入前备份
- ✅ 使用预检查查看重复的hospital_id
- ✅ 导入后验证数据完整性
- ✅ 定期运行健康检查

---

## 📋 最佳实践

### 导入数据库的标准流程

1. **备份当前数据库**
   ```
   文件 → 备份数据库...
   ```

2. **运行健康检查（导入前）**
   ```
   文件 → 数据库健康检查...
   确保当前数据库状态良好
   ```

3. **使用导入预检查**
   ```
   文件 → 导入数据库...
   查看预检查报告
   确认没有问题后再导入
   ```

4. **执行导入**
   ```
   点击"确认导入"
   ```

5. **运行健康检查（导入后）**
   ```
   文件 → 数据库健康检查...
   验证导入成功且无冲突
   ```

6. **抽查数据**
   ```
   随机打开几个患者
   检查数据是否正确
   ```

---

## 💡 常见误解

### 误解1："相同的ID会冲突"

**真相：** 源ID被完全忽略，目标数据库生成全新的ID。

### 误解2："需要手动重新编号"

**真相：** SQLite AUTOINCREMENT自动处理，无需人工干预。

### 误解3："外键关系会断裂"

**真相：** 系统建立ID映射表，自动维护正确的关联。

---

## 🔧 如果真的出现冲突（理论上不会）

### 症状

```
错误信息：UNIQUE constraint failed: Surgery.surgery_id
```

### 原因分析

这意味着代码bug（而非设计问题），可能的原因：
1. ID排除逻辑被修改
2. 直接操作SQL而非使用API
3. 数据库文件损坏

### 解决方案

1. **停止操作**
2. **恢复备份**
3. **联系技术支持**
4. **提供详细日志**

---

## 📞 需要帮助？

### 相关文档

- **详细说明：** `docs/DATABASE_MERGE_SAFETY.md`
- **导入指南：** `README.md` → 数据库导入章节
- **健康检查：** 运行工具自动生成报告

### 技术支持

**Email:** qinzhi100@gmail.com

**提供信息：**
- 健康检查报告
- importer.log 文件
- 操作步骤

---

## 🎉 总结

### 三点保证

1. ✅ **设计安全**：ID排除机制
2. ✅ **技术保证**：SQLite AUTOINCREMENT
3. ✅ **自动验证**：健康检查工具

### 你可以放心

- ✅ 合并任意数量的数据库
- ✅ 不会出现ID冲突
- ✅ 数据关系保持完整

### 建议你做

- ✅ 导入前后都运行健康检查
- ✅ 定期备份数据库
- ✅ 使用预检查功能

---

**结论：你完全不需要担心ID冲突问题！** 🎯

---

**版本：** v3.6.2  
**最后更新：** 2025年11月25日

